package nev:plugins;

interface types {
  /// Represents a cursor in a text editor. Line and column are both zero based.
  /// The column is in bytes.
  record cursor {
    line: s32,
    column: s32,
  }

  /// The column of 'last' is exclusive.
  record selection {
    first: cursor,
    last: cursor,
  }

  record vec2f {
    x: f32,
    y: f32,
  }

  record rect {
    pos: vec2f,
    size: vec2f,
  }

  /// Shared reference to a rope. The rope data is stored in the editor, not in the plugin, so ropes
  /// can be used to efficiently access any document content or share a string with another plugin.
  /// Ropes are reference counted internally, and this resource also affects that reference count.
  resource rope {
    constructor(content: string);
    /// Returns another reference to the same rope.
    clone: func() -> rope;
    /// Returns the number of bytes in the rope. This operation is cheap.
    bytes: func() -> s64;
    /// Returns the number of UTF-8 code points. This operation is cheap.
    runes: func() -> s64;
    /// Returns the number of lines. This operation is cheap.
    lines: func() -> s64;
    /// Returns the text of the rope as a string. This is expensive for large ropes.
    text: func() -> string;
    /// Returns a slice of the rope from 'a' to 'b'. 'a' and 'b' are byte indices, 'b' is exclusive.
    /// This operation is cheap because it doesn't create a copy of the text.
    slice: func(a: s64, b: s64) -> rope;
    /// Returns a slice of the rope from 'a' to 'b'. The column of 'b' is exclusive. Columns are in bytes.
    /// This operation is cheap because it doesn't create a copy of the text.
    slice-points: func(a: cursor, b: cursor) -> rope;
    // /// Returns a slice of the rope from line 'a' to 'b'. 'b' is inclusive.
    // /// This operation is cheap because it doesn't create a copy of the text.
    // slice-lines: func(a: s64, b: s64) -> rope;
  }

  /// Non-owning handle to an editor.
  record editor {
    id: u64
  }

  /// Non-owning handle to a text editor.
  record text-editor {
    id: u64
  }

  /// Non-owning handle to a document.
  record document {
    id: u64
  }

  /// Non-owning handle to a text document.
  record text-document {
    id: u64
  }

  record task {
    id: u64
  }
}

/// Thread safe
interface channel {
  enum channel-listen-response {
    continue,
    stop,
  }

  /// Represents the read end of a channel. All APIs are non-blocking.
  resource read-channel {
    /// Returns whether the channel is still open and usable.
    can-read: func() -> bool;
    /// Returns whether the channel at the end, meaning no further data will be returned from any read function.
    at-end: func() -> bool;
    /// Returns the minimum number of bytes available for reading. More data might be available after calling a read function or 'flush-read'.
    peek: func() -> s32;
    /// Read data into the internal buffer of the channel. This is required for 'peek' to work. Other read functions as well
    /// as 'listen' and 'wait-read' already do this internally so you usually don't need to call 'flush-read'.
    flush-read: func() -> s32;
    /// Read
    read-string: func(num: s32) -> string;
    /// Read
    read-bytes: func(num: s32) -> list<u8>;
    /// Read everything currently available in the channel.
    read-all-string: func() -> string;
    /// Read everything currently available in the channel.
    read-all-bytes: func() -> list<u8>;
    /// Listen for data being ready to read. When data is ready 'fun' is called with 'data'.
    listen: func(fun: u32, data: u32);
    /// If 'num' bytes are available in the channel return true, otherwise return false and call 'task' later once the
    /// requested amount of data is available.
    wait-read: func(task: u64, num: s32) -> bool;

    open: static func(path: string) -> option<read-channel>;
    mount: static func(channel: read-channel, path: string, unique: bool) -> string;
  }

  /// Represents the write end of a channel. All APIs are non-blocking.
  resource write-channel {
    /// Close the write end.
    close: func();
    /// Returns whether the channel is still open and usable.
    can-write: func() -> bool;
    /// Write a string to the channel
    write-string: func(data: string);
    /// Write a buffer to the channel
    write-bytes: func(data: list<u8>);

    open: static func(path: string) -> option<write-channel>;
    mount: static func(channel: write-channel, path: string, unique: bool) -> string;
  }

  /// Creates a new channel which buffers data in memory and returns the read and write end.
  new-in-memory-channel: func() -> tuple<read-channel, write-channel>;
}

/// Thread safe
interface process {
  use channel.{read-channel, write-channel};

  /// Resource which represents a running process started by a plugin.
  resource process {
    /// Start a process with the given name and pass 'args' as command line arguments
    start: static func(name: string, args: list<string>) -> process;
    /// Return a channel for reading from stderr.
    stderr: func() -> read-channel;
    /// Return a channel for reading from stdout.
    stdout: func() -> read-channel;
    /// Return a channel for writing to stdin.
    stdin: func() -> write-channel;
  }
}

interface vfs {
  use types.{rope};
  use commands.{command-error};

  enum vfs-error {
    not-allowed,
    not-found,
  }

  flags read-flags {
    binary,
  }

  /// Read the given file synchronously. Requires 'filesystemRead' permissions.
  /// By default files are checked to be valid UTF-8 when loading. To skip this check pass the 'binary' flag.
  /// Paths are virtual paths for the virtual file system.
  read-sync: func(path: string, read-flags: read-flags) -> result<string, vfs-error>;
  /// Read the given file synchronously. Requires 'filesystemRead' permissions.
  /// By default files are checked to be valid UTF-8 when loading. To skip this check pass the 'binary' flag.
  /// Paths are virtual paths for the virtual file system.
  read-rope-sync: func(path: string, read-flags: read-flags) -> result<rope, vfs-error>;
  /// Write the given file synchronously. Requires 'filesystemWrite' permissions.
  /// Paths are virtual paths for the virtual file system.
  write-sync: func(path: string, content: string) -> result<bool, vfs-error>;
  /// Write the given file synchronously. Requires 'filesystemWrite' permissions.
  /// Paths are virtual paths for the virtual file system.
  write-rope-sync: func(path: string, rope: rope) -> result<bool, vfs-error>;
  /// Turns a virtual file system path to a path in the local file system, which can be passed to e.g. external processes.
  /// E.g. 'local://C:/Users' becomes 'C:/Users'
  /// E.g. 'home://.nev' becomes 'C:/Users/username/.nev'
  localize: func(path: string) -> string;

}

interface editor {
  use types.{editor, document};
  /// Returns a handle for the currently active text editor.
  active-editor: func() -> option<editor>;
  /// Returns the document the given editor is currently editing.
  get-document: func(editor: editor) -> option<document>;
}

interface text-editor {
  use types.{editor, document, text-editor, text-document, cursor, selection, rope};
  use commands.{command-error};

  /// Returns a handle for the currently active text editor.
  active-text-editor: func() -> option<text-editor>;
  /// Returns the text document the given editor is currently editing.
  get-document: func(editor: text-editor) -> option<text-document>;
  /// Try to cast the given editor handle to a text editor handle.
  as-text-editor: func(editor: editor) -> option<text-editor>;
  /// Try to cast the given document handle to a text document handle.
  as-text-document: func(document: document) -> option<text-document>;

  /// Run the given command on the given text editor. This requires 'command' permissions.
  command: func(editor: text-editor, name: string, arguments: string) -> result<string, command-error>;

  /// todo
  record-current-command: func(editor: text-editor, registers: list<string>);

  /// todo
  get-usage: func(editor: text-editor) -> string;
  /// todo
  get-revision: func(editor: text-editor) -> s32;
  /// todo
  set-mode: func(editor: text-editor, mode: string, exclusive: bool);
  /// todo
  mode: func(editor: text-editor) -> string;
  clear-tab-stops: func(editor: text-editor);
  select-next-tab-stop: func(editor: text-editor);
  select-prev-tab-stop: func(editor: text-editor);
  undo: func(editor: text-editor, checkpoint: string);
  redo: func(editor: text-editor, checkpoint: string);
  add-next-checkpoint: func(editor: text-editor, checkpoint: string);
  copy: func(editor: text-editor, register: string, inclusive-end: bool);
  paste: func(editor: text-editor, register: string, inclusive-end: bool);

  apply-move: func(editor: text-editor, selection: selection, move: string, count: s32, wrap: bool, include-eol: bool) -> list<selection>;

  /// Sets the given selection as the only selection for the given editor.
  set-selection: func(editor: text-editor, s: selection);
  /// Sets the selections for the given editor.
  set-selections: func(editor: text-editor, s: list<selection>);
  /// Returns the last selection of the given editor.
  get-selection: func(editor: text-editor) -> selection;
  /// Returns the selections of the given editor.
  get-selections: func(editor: text-editor) -> list<selection>;
  /// Return the length of the given line (0 based)
  line-length: func(editor: text-editor, line: s32) -> s32;
  /// Add a callback which will be called whenever any editor changes mode.
  add-mode-changed-handler: func(fun: u32) -> s32;

  edit: func(editor: text-editor, selections: list<selection>, contents: list<string>) -> list<selection>;

  /// Returns the rope containing the current content of the text editors document.
  /// This rope is not automatically kept up to date when the document changes, but
  /// represents the content at the point in time this is called instead. Keeping ropes
  /// around should not have significant memory overhead because ropes share data under the hood.
  content: func(editor: text-editor) -> rope;
}

interface registers {
  /// todo
  is-replaying-commands: func() -> bool;
  /// todo
  set-register-text: func(text: string, register: string);
  /// todo
  start-recording-commands: func(register: string);
}

interface text-document {
  use types.{text-document, cursor, selection, rope};

  /// Returns the rope containing the current content of the document.
  /// This rope is not automatically kept up to date when the document changes, but
  /// represents the content at the point in time this is called instead. Keeping ropes
  /// around should not have significant memory overhead because ropes share data under the hood.
  content: func(document: text-document) -> rope;
}

interface layout {
  /// Shared handle for a view.
  record view {
    id: s32
  }

  /// Show the given view in the given slot.  If focus is true it's also focused, otherwise focus remains as is if possible.
  show: func(v: view, slot: string, focus: bool, add-to-history: bool);
  /// Close the given view. If 'keep-hidden' is true then the view will only be removed from the layout tree but remains open
  /// in the background. If 'restore-hidden' is true the the current view will be replaced by the last hidden view,
  /// otherwise the current slot is removed from the layout.
  close: func(v: view, keep-hidden: bool, restore-hidden: bool);
  /// Set focus to the view in the given slot.
  focus: func(slot: string);
}

interface render {
  use types.{vec2f};
  use layout.{view};

  /// Shared handle to a custom render view
  resource render-view {
    constructor();

    /// Try to create a handle to an existing render view with the given user id.
    from-user-id: static func(id: string) -> option<render-view>;
    /// Try to create a handle to an existing render view from a 'view'.
    from-view: static func(v: view) -> option<render-view>;
    /// Returns the raw view handle.
    view: func() -> view;
    /// Returns the unique id of the view. This id is not stable across sessions.
    id: func() -> s32;
    /// Returns the size in pixels the view currently has. In the terminal one pixel is one character.
    size: func() -> vec2f;
    /// Returns whether the given key is currently pressed.
    key-down: func(key: s64) -> bool;
    /// Specify how often the view should render. -1 means don't render in a timer, 0 means render every frame,
    /// a number bigger than 0 specifies the interval in milliseconds.
    set-render-interval: func(ms: s32);
    /// Set the render commands used for the next render. 'buffer' is a pointer to a buffer of encoded render commands,
    /// 'len' is the length of the buffer in bytes.
    set-render-commands-raw: func(buffer: u32, len: u32);
    /// Set the render commands used for the next render. 'data' contains encoded render commands.
    set-render-commands: func(data: list<u8>);
    /// Enable rendering while the view is inactive (but still visible).
    set-render-when-inactive: func(enabled: bool);
    /// When enabled the view prevents the editor from throttling the frame rate after a few seconds. This requires
    /// the view to also be rendered regularly, using e.g. 'set-render-interval' or but marking it dirty regularly.
    set-prevent-throttling: func(enabled: bool);
    /// Sets the user id of this view.
    set-user-id: func(id: string);
    /// Returns the user id of this view.
    get-user-id: func() -> string;
    /// Trigger a render for this view.
    mark-dirty: func();
    /// Sets the callback which wil be called before rendering. This can be used to set the render commands.
    /// 'fun' is a pointer to a function with signature func(id: s32, data: u32). Data is an arbitrary number
    /// which will be passed to the callback unchanged. It can be used as e.g. a pointer to some data.
    set-render-callback: func(fun: u32, data: u32);
    /// Set the list of input modes. This controls which keybindings are available while the view is active.
    set-modes: func(modes: list<string>);
    /// Add a mode to the input modes. This controls which keybindings are available while the view is active.
    add-mode: func(mode: string);
    /// Remove a mode from the input modes. This controls which keybindings are available while the view is active.
    remove-mode: func(mode: string);
  }
}

/// Thread safe
interface core {
  enum platform {
    gui,
    tui,
  }

  enum background-executor {
    thread,
    thread-pool,
  }

  /// Returns the plugin API version this plugin is using.
  /// 0 means the latest version, 1 or bigger means a specific version.
  api-version: func() -> s32;

  /// Returns the time since the plugin was loaded. Returns 0 if the plugin has no 'time' permission.
  get-time: func() -> f64;

  /// Returns what kind platform the app is running on. E.g. 'terminal' or 'gui'
  get-platform: func() -> platform;

  /// Returns true if this plugin is running on the main thread. Some APIs are not available when not on the main thread.
  is-main-thread: func() -> bool;

  /// Returns the arguments this plugin instance was created with.
  get-arguments: func() -> string;

  /// Creates another instance of the plugin running in a background thread. 'args' is available in the new instance
  /// using the 'get-arguments' function
  spawn-background: func(args: string, executor: background-executor);

  /// Destroy the current plugin instance.
  finish-background: func();
}

interface commands {
  enum command-error {
    not-allowed,
    not-found
  }

  /// Defines a command.
  define-command: func(name: string, active: bool, docs: string, params: list<tuple<string, string>>, returntype: string, context: string, fun: u32, data: u32);

  /// Run the given command. This requires 'command' permissions.
  run-command: func(name: string, arguments: string) -> result<string, command-error>;
}

interface settings {
  /// Returns the value of the setting with the given path, encoded as JSON.
  get-setting-raw: func(name: string) -> string;

  /// Set the value of the setting with the given path. The value must be encoded as JSON.
  set-setting-raw: func(name: string, value: string);
}

interface guest {
  use render.{view};
  use channel.{channel-listen-response};
  init-plugin: func();
  handle-command: func(fun: u32, data: u32, arguments: string) -> string;
  handle-mode-changed: func(fun: u32, old: string, new: string);
  handle-view-render-callback: func(id: s32, fun: u32, data: u32);
  handle-channel-update: func(fun: u32, data: u32, closed: bool) -> channel-listen-response;
  notify-task-complete: func(task: u64, canceled: bool);
}

/// APIs which can safely be used on a background thread
world plugin-thread-safe {
  use types.{cursor, selection};

  import core;
  import channel;
  import process;

  export guest;
}

world plugin {
  use types.{cursor, selection};

  import core;
  import commands;
  import settings;
  import editor;
  import text-editor;
  import text-document;
  import render;
  import vfs;
  import channel;
  import process;
  import registers;

  export guest;
}
